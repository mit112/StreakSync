rules_version = '2';

// StreakSync Firestore Security Rules
// Deploy: firebase deploy --only firestore:rules

service cloud.firestore {
  match /databases/{database}/documents {
    function hasRequiredAndOnly(required, optional) {
      let allAllowed = required.concat(optional);
      return request.resource.data.keys().hasAll(required)
        && request.resource.data.keys().hasOnly(allAllowed);
    }

    function isSignedIn() {
      return request.auth != null;
    }

    // --- Users ---
    // Full profile readable by the user themselves or their accepted friends.
    // The 'friends' array on each user document is maintained by the app.
    match /users/{userId} {
      allow read: if isSignedIn()
        && (request.auth.uid == userId
            || request.auth.uid in resource.data.friends);
      allow create: if isSignedIn() && request.auth.uid == userId;
      allow update: if isSignedIn() && request.auth.uid == userId;
      allow delete: if false;

      // --- Game Results (private per-user) ---
      match /gameResults/{resultId} {
        allow read, write: if request.auth != null && request.auth.uid == userId;
      }

      // --- Sync data (achievements, private per-user) ---
      match /sync/{docId} {
        allow read, write: if request.auth != null && request.auth.uid == userId;
      }
    }

    // --- Friend Codes ---
    // Minimal lookup collection: { userId, displayName }
    // Readable by any authenticated user (needed for friend code entry).
    // Only the code owner can write (via the app's generateFriendCode flow).
    match /friendCodes/{code} {
      allow read: if isSignedIn();
      allow write: if isSignedIn()
        && request.resource.data.userId == request.auth.uid
        && hasRequiredAndOnly(['userId', 'displayName'], [])
        && request.resource.data.userId is string
        && request.resource.data.displayName is string;
    }

    // --- Scores ---
    // Leaderboard scores. Each score document includes an `allowedReaders`
    // array set at publish time to [publisher] + [publisher's friends].
    // Reads are restricted to users in that array.
    //
    match /scores/{scoreId} {
      allow read: if isSignedIn()
        && request.auth.uid in resource.data.allowedReaders;

      allow create, update: if isSignedIn()
        && request.resource.data.userId == request.auth.uid
        && hasRequiredAndOnly(
          ['userId', 'gameId', 'dateInt', 'gameName', 'completed', 'allowedReaders'],
          ['score', 'maxAttempts', 'currentStreak', 'publishedAt']
        )
        && request.resource.data.userId is string
        && request.resource.data.gameId is string
        && request.resource.data.dateInt is int
        && request.resource.data.completed is bool
        && request.resource.data.gameName is string
        && request.resource.data.allowedReaders is list
        && request.auth.uid in request.resource.data.allowedReaders
        && (!('score' in request.resource.data) || request.resource.data.score is int)
        && (!('maxAttempts' in request.resource.data) || request.resource.data.maxAttempts is int)
        && (!('currentStreak' in request.resource.data) || request.resource.data.currentStreak is int);

      allow delete: if false;
    }

    // --- Friendships ---
    match /friendships/{friendshipId} {
      // Read: either party
      allow read: if isSignedIn()
        && (resource.data.userId1 == request.auth.uid
            || resource.data.userId2 == request.auth.uid);

      // Create: sender must be userId1, status must start as pending,
      // required fields present, sender != recipient
      allow create: if isSignedIn()
        && request.resource.data.userId1 == request.auth.uid
        && request.resource.data.userId1 != request.resource.data.userId2
        && request.resource.data.status == 'pending'
        && hasRequiredAndOnly(['userId1', 'userId2', 'status', 'createdAt'], ['senderDisplayName'])
        && request.resource.data.userId1 is string
        && request.resource.data.userId2 is string;

      // Update: ONLY the recipient (userId2) can accept,
      // and ONLY the status field may change (to 'accepted').
      // userId1, userId2 are immutable.
      allow update: if isSignedIn()
        && resource.data.userId2 == request.auth.uid
        && request.resource.data.status == 'accepted'
        && resource.data.status == 'pending'
        && request.resource.data.userId1 == resource.data.userId1
        && request.resource.data.userId2 == resource.data.userId2;

      // Delete: either party can remove the friendship
      allow delete: if isSignedIn()
        && (resource.data.userId1 == request.auth.uid
            || resource.data.userId2 == request.auth.uid);
    }

    // Deny everything else
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
