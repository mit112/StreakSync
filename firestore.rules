rules_version = '2';

// StreakSync Firestore Security Rules
// Deploy: firebase deploy --only firestore:rules

service cloud.firestore {
  match /databases/{database}/documents {

    // --- Users ---
    // Full profile readable by the user themselves or their accepted friends.
    // The 'friends' array on each user document is maintained by the app
    // when friendships are accepted/removed.
    //
    // Progressive tightening: profiles WITHOUT a 'friends' field (legacy)
    // remain readable by any authenticated user. Once the user opens the
    // app and the field is backfilled, reads are restricted to self + friends.
    // This prevents breaking queries during the migration period.
    match /users/{userId} {
      allow read: if request.auth != null
        && (request.auth.uid == userId
            || !('friends' in resource.data)
            || request.auth.uid in resource.data.friends);
      allow create: if request.auth != null && request.auth.uid == userId;
      allow update: if request.auth != null && request.auth.uid == userId;
      allow delete: if false;

      // --- Game Results (private per-user) ---
      match /gameResults/{resultId} {
        allow read, write: if request.auth != null && request.auth.uid == userId;
      }

      // --- Sync data (achievements, private per-user) ---
      match /sync/{docId} {
        allow read, write: if request.auth != null && request.auth.uid == userId;
      }
    }

    // --- Friend Codes ---
    // Minimal lookup collection: { userId, displayName }
    // Readable by any authenticated user (needed for friend code entry).
    // Only the code owner can write (via the app's generateFriendCode flow).
    match /friendCodes/{code} {
      allow read: if request.auth != null;
      allow write: if request.auth != null
        && request.resource.data.userId == request.auth.uid
        && request.resource.data.keys().hasAll(['userId', 'displayName'])
        && request.resource.data.displayName is string;
    }

    // --- Scores ---
    // Leaderboard scores. Each score document includes an `allowedReaders`
    // array set at publish time to [publisher] + [publisher's friends].
    // Reads are restricted to users in that array.
    //
    // Migration: scores without `allowedReaders` (pre-v2) remain readable
    // by any authenticated user. Once all clients are updated and old scores
    // age out, remove the !('allowedReaders' in ...) fallback.
    match /scores/{scoreId} {
      allow read: if request.auth != null
        && (!('allowedReaders' in resource.data)
            || request.auth.uid in resource.data.allowedReaders);

      allow create, update: if request.auth != null
        && request.resource.data.userId == request.auth.uid
        && request.resource.data.keys().hasAll(['userId', 'gameId', 'dateInt', 'gameName', 'completed'])
        && request.resource.data.dateInt is int
        && request.resource.data.completed is bool
        && request.resource.data.gameName is string
        && request.resource.data.gameId is string
        && (!('allowedReaders' in request.resource.data)
            || request.auth.uid in request.resource.data.allowedReaders);

      allow delete: if false;
    }

    // --- Friendships ---
    match /friendships/{friendshipId} {
      // Read: either party
      allow read: if request.auth != null
        && (resource.data.userId1 == request.auth.uid
            || resource.data.userId2 == request.auth.uid);

      // Create: sender must be userId1, status must start as pending,
      // required fields present, sender != recipient
      allow create: if request.auth != null
        && request.resource.data.userId1 == request.auth.uid
        && request.resource.data.userId1 != request.resource.data.userId2
        && request.resource.data.status == 'pending'
        && request.resource.data.keys().hasAll(['userId1', 'userId2', 'status', 'createdAt']);

      // Update: ONLY the recipient (userId2) can accept,
      // and ONLY the status field may change (to 'accepted').
      // userId1, userId2 are immutable.
      allow update: if request.auth != null
        && resource.data.userId2 == request.auth.uid
        && request.resource.data.status == 'accepted'
        && resource.data.status == 'pending'
        && request.resource.data.userId1 == resource.data.userId1
        && request.resource.data.userId2 == resource.data.userId2;

      // Delete: either party can remove the friendship
      allow delete: if request.auth != null
        && (resource.data.userId1 == request.auth.uid
            || resource.data.userId2 == request.auth.uid);
    }

    // Deny everything else
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
