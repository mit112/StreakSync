<!-- 41583620-d0eb-491e-9d70-7242f5164b89 1df4238a-1c0b-4600-8980-1d096bdbc4bc -->
# StreakSync Social System Redesign ‚Äì Implementation Plan

## Goals

- Clarify and simplify the mental model for social features (friends, circles, leaderboards).
- Remove vestigial friend-code flows and align with platform-native contact discovery.
- Support multiple circles (family, work, etc.) instead of a single shared group.
- Preserve existing data, avoid regressions, and provide clear migration and rollback paths.
- Improve performance (caching, incremental sync) and add granular privacy controls.

## Step 0 ‚Äì Pre-Implementation Analysis

1. **Confirm platform and feature constraints**

- Verify current minimum iOS deployment target in `StreakSync` target settings.
- Confirm we can rely on Contacts + CloudKit discoverability (and document behavior when unavailable).

2. **Inventory current social system**

- In `Core/Services/Social/`, map all usages of `SocialService`, `HybridSocialService`, `MockSocialService`.
- In `Features/Friends/` and `Features/Shared/Views/FriendsView.swift`, list all user-visible friend/leaderboard entry points.

3. **Data/Key mapping**

- Enumerate UserDefaults keys used by social features: `social_mock_*`, `friends_last_*`, `selectedLeaderboardGroup*`, etc.
- Enumerate CloudKit zones/record types actually created by the app (cross-check with `CLOUDKIT_REFERENCE.md`).

4. **Usage & pain analytics (if available)**

- Identify where in the flow users most often drop (e.g., open Friends tab but never share).
- Define logging points for current friend-code usage to inform deprecation timing.

## Step 1 ‚Äì Deprecate Friend Codes (Non-breaking)

1. **Code-level deprecation**

- Add `@available(*, deprecated, message: "Friend codes are being replaced by contact-based discovery.")` to `generateFriendCode()` and `addFriend(using:)` in `SocialService` protocol and its implementations.
- Add internal comments in `MockSocialService` and `HybridSocialService` explaining deprecation and retained behavior for migration.

2. **UI soft-hiding**

- In `FriendsView` and `FriendManagementView`, introduce a feature flag (e.g., `SocialFeatures.friendCodesEnabled`) and hide friend-code sections when disabled.
- Replace friend-code CTAs with a short, dismissible notice: ‚ÄúFinding friends will soon be automatic via your contacts. Existing connections stay intact.‚Äù

3. **Instrumentation**

- Log whenever `generateFriendCode()` or `addFriend(using:)` are called (e.g., via existing analytics service) so you can monitor residual usage.
- Add a temporary debug screen/console log to show friend-code usage counts during testing.

## Step 2 ‚Äì Simplify Service Architecture

1. **Design the unified social service API**

- Draft a new protocol (e.g., `SimpleSocialService`) with methods: `discoverFriends`, `addFriend`, `createCircle`, `joinCircle`, `publishScore`, `leaderboard(for:dateRange:)`.
- Map existing `SocialService` methods to new ones and define which old methods become thin adapters.

2. **Introduce `CloudKitSocialService`**

- Create `Core/Services/Social/CloudKitSocialService.swift` implementing the new protocol, encapsulating CloudKit and local caching in one class.
- Internally, reuse parts of `LeaderboardSyncService` and `MockSocialService` logic where appropriate (e.g., local caching, model encoding).

3. **Adapter layer for backward compatibility**

- Implement an adapter (e.g., `LegacySocialServiceAdapter`) that presents the old `SocialService` API on top of `CloudKitSocialService`, so existing callers keep working while you incrementally migrate them.

4. **Plan for removal of Hybrid/Mock services**

- Identify call sites where `HybridSocialService` is created (e.g., `AppContainer`).
- Define a migration path where `AppContainer` constructs only `CloudKitSocialService` (with built-in local fallback) once you are ready to remove the old types.

## Step 3 ‚Äì Data Model Redesign

1. **Define new core models** (in `Core/Models/Social/`)

- Add `User`, `Friendship`, `FriendshipSource`, `Circle`, and `GameScore` as per your redesign document.
- Provide conversion helpers from existing `UserProfile`, `DailyGameScore`, and CloudKit records to the new models.

2. **Migration helpers**

- Implement functions to map existing `UserProfile` ‚Üí `User`, existing ‚Äúfriend codes‚Äù list ‚Üí `[Friendship]`, and the current single shared group ‚Üí initial `Circle`.
- Add a small, idempotent migration routine (e.g., `SocialMigration.migrateIfNeeded()`) that runs once on launch, guarded by a `social_migration_version` key in UserDefaults.

3. **Update scoring layer to use `GameScore`**

- Refactor `LeaderboardScoring` to accept `GameScore` or add lightweight adapters so the new code path can use it without breaking tests.
- Update unit tests in `LeaderboardScoringTests` to cover the new model while keeping old tests passing.

## Step 4 ‚Äì Contact Discovery & Permissions

1. **Permissions UX design**

- Design a dedicated ‚ÄúFind Friends Who Play‚Äù screen (new view in `Features/Friends/Views/`) matching the flow in your plan (Not Now / Find Friends, explainer text, etc.).
- Decide where this appears: first app launch, first time opening Friends tab, or as a button.

2. **Implement Contacts + discoverability prompts**

- Add a small service (e.g., `ContactsPermissionManager`) to request and track Contacts authorization.
- Use `CKContainer.requestApplicationPermission(.userDiscoverability)` and persist the decision.

3. **Implement discovery pipeline**

- In `CloudKitSocialService`, implement `discoverFriendsInContacts()` using `CKDiscoverAllUserIdentitiesOperation` (or its modern equivalents) and map results to `User` + `Friendship` models.
- Add caching (e.g., last discovery timestamp + cached list for 24 hours) in local storage (UserDefaults or a small local DB).

4. **Fallback and manual addition**

- Define a simple username scheme (e.g., derived from CK user record name) and implement `addFriend(byUsername:)` for edge cases where contacts-based discovery is not possible.
- Expose this in a secondary UI path (e.g., an ‚ÄúAdd by username‚Äù field in Friends screen), clearly labelled as advanced.

## Step 5 ‚Äì Circles (Multiple Groups)

1. **CloudKit schema design**

- Finalize record/zone layout for circles: e.g., `circles_{ownerId}` zone, `Circle`, `CircleMembership`, `CircleInvitation` record types.
- Update `CLOUDKIT_REFERENCE.md` with the new schema.

2. **Local representation & caching**

- Implement local storage for circles (e.g., encoded `[Circle]` per user) with change tokens for CloudKit sync.

3. **Circle management APIs**

- In `CloudKitSocialService`, implement:
- `createCircle(name:members:)`
- `joinCircle(inviteMetadataOrURL:)`
- `leaveCircle(id:)`
- `listCircles()`

4. **UI integration**

- Add a Circles sub-screen under the Friends tab as per your IA (in `Features/Friends/Views/`): list circles, invitations, and create-circle flow.
- Add a circle filter to the leaderboard header (e.g., dropdown/chip control) that feeds into leaderboard queries.

5. **Migration from single group**

- During migration, convert the existing `LeaderboardGroupStore.selectedGroupId` into a first `Circle` named ‚ÄúFriends‚Äù and associate existing scores with that circle.

## Step 6 ‚Äì Circle-based Leaderboards

1. **Extend leaderboard queries**

- Update `leaderboard(for circle: Circle?, dateRange: DateRange)` in `CloudKitSocialService` to:
- Filter scores by circle membership.
- Support ‚ÄúAll Friends‚Äù (circle == nil) by aggregating across all circles/friendships.

2. **FriendsViewModel refactor**

- Replace current group-based global leaderboard calls with circle-aware calls.
- Introduce state for currently selected circle (and default to ‚ÄúAll Friends‚Äù).
- Ensure rank-delta logic still works with per-circle leaderboards.

3. **UI behavior**

- In `FriendsView`, add a circle selector to the header.
- Ensure empty states and CTAs are circle-aware (e.g., ‚ÄúNo scores in this circle yet. Invite friends.‚Äù).

## Step 7 ‚Äì Privacy Controls & Sharing Rules

1. **Settings model**

- Add a `SocialPrivacySettings` model with per-game sharing scopes (e.g., `none`, `friends`, `circles([UUID])`).
- Store this in a new settings service (`SocialSettingsService`) backed by UserDefaults.

2. **Settings UI**

- In the Settings tab (likely under `Features/Settings/`), create a ‚ÄúSocial & Privacy‚Äù screen with per-game sharing controls and global toggles (e.g., ‚ÄúHide incomplete games‚Äù).

3. **Enforcement in publish path**

- Update the score publishing pipeline in `AppState` ‚Üí `CloudKitSocialService.publishScore` to filter out scores that should not be published according to privacy settings.

4. **Leaderboard filtering**

- Ensure leaderboard aggregation respects privacy rules: do not include scores that the user has opted to hide.

## Step 8 ‚Äì Enhanced Social Features (Reactions, Activity Feed)

1. **Reactions model & storage**

- Define a lightweight `Reaction` model (userId, targetScoreId or date/game, type, timestamp).
- Store reactions in a separate CloudKit record type (and optionally cached locally).

2. **Activity feed service**

- Implement an `ActivityFeedService` that aggregates events: reactions, streak milestones, new circles, and rank changes.

3. **UI feed**

- Add an Activity subtab under Friends or integrate a compact feed into Friends/Today views.
- Add quick reaction buttons on leaderboard rows (e.g., ‚Äúüëè‚Äù, ‚Äúüî•‚Äù).

4. **Notifications**

- Integrate with existing notification system so key events (e.g., a friend reacting to your score) can trigger push notifications with appropriate throttling.

## Step 9 ‚Äì Performance, Caching, and Offline Support

1. **Cache layering**

- Implement an in-memory cache in `CloudKitSocialService` for current-day leaderboard, friend list, and circles.
- Add a small on-disk cache (e.g., using a Codable file or lightweight database) for recent leaderboards and profiles.

2. **Incremental sync**

- Use `CKFetchRecordZoneChangesOperation` (or modern equivalent) for circle zones and score zones, maintaining change tokens.

3. **Offline queuing**

- Implement a queue for pending score publications and reactions when offline, with retry logic when connectivity returns.

4. **Background refresh**

- If allowed by app constraints, use background tasks/refresh to periodically sync leaderboards and clear queues.

## Step 10 ‚Äì UI/UX Refinement

1. **Navigation restructure**

- Update `MainTabView` to match the new IA (Today, Games, Friends with subtabs, Profile) if not already aligned.

2. **Friends tab redesign**

- Refactor `FriendsView` into smaller components: `FriendsLeaderboardView`, `FriendsListView`, `CirclesView`, and a top-level container for switching between them.

3. **Leaderboard visual hierarchy**

- Implement the new header (date selector, circle filter, view toggle), leaderboard cells (rank, delta, reactions), and footer (your rank, stats) with the existing design system.

4. **Friend management flows**

- Replace friend-code flows with the new ‚ÄúFrom Contacts‚Äù and ‚ÄúYour Friends‚Äù lists, plus invitations and circle management screens.

5. **Onboarding & messaging**

- Add onboarding cards/tooltips explaining the new social model (friends, circles, privacy) to reduce confusion.

## Step 11 ‚Äì Testing, Beta, and Rollout

1. **Automated tests**

- Add unit tests for:
- Contact discovery mapping.
- Circle CRUD operations and membership rules.
- Privacy enforcement and score filtering.
- Migration logic and idempotency.
- Add integration tests for CloudKit operations and offline queuing.
- Add UI tests for core flows (find friends, create circle, view leaderboard).

2. **Feature flagging**

- Wrap the new social system behind a feature flag so you can enable it for beta users first.

3. **Beta rollout**

- Use TestFlight phases (internal ‚Üí power users ‚Üí broader beta) and collect feedback via in-app prompts/analytics.

4. **Staged production rollout**

- Roll out to increasing percentages of users while monitoring crash rates, CloudKit errors, and support tickets.

5. **Rollback plan**

- Ensure you can flip the feature flag off and fall back to the legacy system if metrics cross thresholds.

## Step 12 ‚Äì Post-Launch Monitoring & Iteration

1. **Monitoring & dashboards**

- Set up dashboards for friend additions, circle creations, leaderboard views, errors, and CloudKit usage.

2. **User feedback loop**

- Review support tickets and in-app feedback weekly; prioritize UX polish and bug fixes.

3. **Iterative enhancements**

- Plan follow-up iterations: multi-circle comparisons, public circles, tournaments, advanced analytics.

### To-dos

- [ ] Soft-deprecate friend-code APIs and UI, add instrumentation, and communicate upcoming changes in-app.
- [ ] Define and implement a unified CloudKitSocialService API with local caching that replaces HybridSocialService and MockSocialService over time.
- [ ] Add permissions flow and CK-based contact discovery, plus caching and manual username fallback.
- [ ] Add Circle data model, CloudKit schema, and UI for creating/joining/leaving circles and filtering leaderboards.
- [ ] Introduce per-game social privacy settings, settings UI, and enforcement in score publishing and aggregation.
- [ ] Implement reactions, activity feed, and related notifications on top of the new social model.
- [ ] Implement caching, incremental sync, offline queuing, and background refresh for social data.
- [ ] Refactor Friends tab into leaderboard/friends list/circles views with the new IA and visual hierarchy.
- [ ] Add automated tests, run phased TestFlight and staged production rollout with feature flags and rollback support.